### 10.5.1 비동기적 병렬 처리의 개념

다른 동시성 모델을 사용하는 대부분의 프로그램은 선형적으로 작성되며, 적절하게 콘텍스트를 변경하고자 해당 언어의 런타임이나 운영체제의 스레드 또는 프로세스 관리에 의존한다. `asyncio` 기반 어플리케이션은 명시적으로 콘텍스트 변경을 처리하는 코드가 있어야 하며, 이 기술을 올바르게 사용하려면 몇 가지 관련된 개념을 이해할 필요가 있다.

`asyncio`가 제공하는 프레임워크는 I/O 이벤트, 시스템 이벤트, 어플리케이션 콘텍스트 변경을 효율적으로 처리하는 객체인 이벤트 루프에 중점을 두고 있다. 다양한 루프 구현이 제공되므로 운영체제의 가용성에 따라 이점을 활용할 수 있다. 적정한 기본값이 자동으로 선택되지만 어플리케이션에서 특정 이벤트 루프 구현을 선택할 수도 있다. 예를 들어 일부 루프 클래스가 네트워크 I/O에서 어느 정도의 효율성을 희생하는 대신에 외부 프로세스에 대한 지원을 추가하는 윈도우에서 매우 유용하다.

어플리케이션은 이벤트 루프와 명시적으로 상호작용을 하면서 실행할 코드를 등록하고, 리소스가 가용할 때 이벤트 루프가 필요한 어플리케이션 코드를 호출하게 한다. 예를 들어 네트워크 서버는 소켓을 열고 소켓에서 입력 이벤트가 발생했을 때 알림을 받고자 소켓을 등록한다. 새로 들어오는 연결이 설정됐거나 데이터를 읽을 수 있을 때 이벤트 루프는 서버 코드에게 이를 알린다. 어플리케이션 코드는 현재 콘텍스트에서 수행할 작업이 더 이상 없으면 잠깐 후에 제어를 넘겨 준다. 예를 들어 소켓에 읽을 데이터가 더 이상 없으면 서버는 이벤트 루프에 제어를 돌려준다.

이벤트 루프에 제어를 돌려주는 메커니즘은 자신의 상태를 잃지 않으면서 호출자에서 제어를 양도하는 특수한 함수인 파이썬 코루틴에 달려 있다. 코루틴은 생성자 함수와 매우 비슷한다. 실제로 파이썬 3.5 이전 버전에서 생성자는 코루틴 객체에 대한 지원을 하는 것이 아니라 코루틴을 구현하는데 사용할 수 있었다. 또한 `asyncio`는 코루틴을 직접 작성하는 대신 콜백을 사용해 코드를 작성할 수 있는 프로토콜 계층 및 전송 계층의 클래스 기반 추상 계층을 제공한다. 클래스 기반 모델과 코루틴 모델 두 가지 모두에서 이벤트 루프 재진입으로 인한 명시적인 콘텍스트 변경은 파이썬의 스레딩 구현에서의 암시적인 콘텍스트 변경을 대체한다.
`Future`는 아직 완료되지 않은 작업의 결과를 나타내는 자료 구조다. 이벤트 루프는 future객체가 완료되는 것을 감시할 수 있기 때문에 어플리케이션의 한 부분을 다른 부분들이 작업을 끝낼 때까지 기다리게 한다. future외에도 `asyncio`는 락이나 세마포어와 같은 기본적인 동시성 도구를 포함한다.

task는 코루틴의 실행을 래핑하고 관리하는 future의 서브 클래스다. 이벤트 루프는 필요한 리소스가 가용할 때 실행돼 다른 코루틴에 의해 사용될 수 있는 결과를 생성하도록 task를 예약한다.
