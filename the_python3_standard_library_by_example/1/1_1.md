## 1.1 string: 텍스트 상수와 템플릿

string 모듈의 기원은 파이썬 초기 버전까지 거슬러 올라간다. 이전에 구현됐던 많은 기능은 str 객체로 이관됐다. 하지만 string 모듈은 아직도 str객체와 작업에 유용한 일부 상수와 클래스를 갖고 있다. 1장에서는 이 부분을 집중적으로 다룬다.

### 1.1.1 함수
capwords() 함수는 문자열에서 모든 단어의 첫 알파벳을 대문자로 바꿔준다.

```python
# string_capwords.py
import string

s = "The      quick brown fox jumped over the lazy dog."
print(repr(s))
print(repr(string.capwords(s)))
```

실행 결과는 주어진 문자열에 대해 split()을 호출한 후 단어의 첫 글자를 대문자로 바꾸고 다시 이 결과에 join을 호출해 하나의 문자열을 만들어낸 것과 동일하다.

```
$ python38 string_capwords.py
'The      quick brown fox jumped over the lazy dog.'
'The Quick Brown Fox Jumped Over The Lazy Dog.'
```

### 1.1.2 템플릿
문자열 템플릿은 [PEP292](https://www.python.org/dev/peps/pep-0292/)의 일환으로 내장된 보간(built-in interpolation) 문법을 대체할 의도로 추가됐다. string.Template을 사용하면 변수명에 $ 접두어를 추가해 식별할 수 있다. 예를 들어 $var과 같다. 또 다른 방법으로는 필요에 따라 중괄호를 사용해 텍스트를 분리시킬수 있다. 예를 들면 ${var}와 같다.
다음 예제는 % 연산자를 사용해 유사 문자열 보간(interpolation)을 가진 단순한 템플릿과 str.format()을 사용하는 새로운 문자열 문법을 비교한다.

```python
# string_template.py
import string

values = {'var': 'foo'}

t = string.Template("""
Variable        : $var
Escape          : $$
Variable in text: ${var}iable
""")
print("TEMPLATE:", t.substitute(values))

s = """
Variable        : %(var)s
Escape          : %%
Variable in text: %(var)siable
"""
print("INTERPOLATION", s % values)

value = "foo"
f = f"""
Variable        : {value}
"""
print("F-STRING", f)
```

```
$ python38 string_template.py
TEMPLATE: 
Variable        : foo
Escape          : $
Variable in text: fooiable

INTERPOLATION 
Variable        : foo
Escape          : %
Variable in text: fooiable

F-STRING 
Variable        : foo
```

템플릿과 문자열 보간(또는 포맷)의 주요 차이점은 인자 타입이 고려되는지의 여부다. 값은 문자열로 변환되고 문자열이 결과로 들어간다. 형식화에 따른 옵션도 없다. 예를 들어 부동소수점값(floating-point value)을 표현하는 소수 아래의 개수를 정할 수 없다. safe_subtitute() 메서드를 사용하는 경우 템플릿이 필요로 하는 모든 값이 인자로 제공되지 않았을때 발생하는 예외를 피할수 있다는 장점이 있다.


```python
# string_template_missing.py
import string

values = dict(var='foo')

t = string.Template("$var is here but $missing is not provided")
try:
    print('subtitute()     :', t.substitute(values))
except KeyError as err:
    print("ERROR", str(err))

print('safe_subtitute():', t.safe_substitute(values))
```

값(values) 딕셔너리에는 missing에 해당하는 값이 없다. 따라서 subtitute()에 의해  KeyError가 발생한다. safe_subtitute()를 사용하면 에러가 발생하는 대신 텍스트 속에 변수 표현식을 그대로 남겨 둔다.

```
$ python38 string_template_missing.py
ERROR 'missing'
safe_subtitute(): foo is here but $missing is not provided
```
